"use strict";
var _ = require("lodash");
var Injector = (function () {
    function Injector() {
        this.injectables = new Map();
    }
    Injector.provide = function (type, instance) {
        return this.INSTANCE.provide(type, instance);
    };
    Injector.construct = function (clazz, injectables) {
        return this.INSTANCE.construct(clazz, injectables);
    };
    Injector.constructAndProvide = function (clazz, injectables) {
        return this.INSTANCE.constructAndProvide(clazz, injectables);
    };
    Injector.get = function (type, extras) {
        return this.INSTANCE.get(type, extras);
    };
    Injector.compile = function (types, injectables) {
        return this.INSTANCE.compile(types, injectables);
    };
    /**
     * Make a class/value accessible globally using the Injector.
     */
    Injector.prototype.provide = function (type, instance) {
        if (!instance) {
            instance = type;
            type = instance.constructor;
        }
        this.injectables.set(type, instance);
    };
    /**
     * Construct a class using global injectables.
     */
    Injector.prototype.construct = function (clazz, injectables) {
        var types = Reflect.getMetadata("design:paramtypes", clazz) || [];
        return new (clazz.bind.apply(clazz, [void 0].concat(this.compile(types, injectables))))();
    };
    Injector.prototype.constructAndProvide = function (clazz, injectables) {
        this.provide(clazz, this.construct(clazz, injectables));
    };
    /**
     * Get an injectable by type
     */
    Injector.prototype.get = function (type, extras) {
        return extras.get(type) || this.injectables.get(type);
    };
    /**
     * Returns an array of values from the injector based on the types given.
     */
    Injector.prototype.compile = function (types, injectables) {
        if (injectables === void 0) { injectables = []; }
        var locals;
        var extras = [];
        if (_.isArray(injectables)) {
            locals = new Map();
            injectables.forEach(function (injectable) {
                if (!_.isObject(injectable) || _.isPlainObject(injectable)) {
                    extras.push(injectable);
                }
                else {
                    locals.set(injectable.constructor, injectable);
                }
            });
        }
        else {
            locals = injectables;
        }
        var instances = [];
        for (var i = 0, len = types.length; i < len; i++) {
            if (types[i] === Object)
                continue;
            var injectable = this.get(types[i], locals);
            instances.push(injectable);
        }
        instances = instances.concat(extras);
        return instances;
    };
    Injector.prototype.fromArray = function (injectables, type) {
        for (var i = 0, len = injectables.length; i < len; i++) {
            if (injectables[i].constructor == type) {
                return injectables[i];
            }
        }
        return null;
    };
    Injector.INSTANCE = new Injector();
    return Injector;
}());
exports.Injector = Injector;
//# sourceMappingURL=injector.js.map